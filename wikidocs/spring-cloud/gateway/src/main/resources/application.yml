server:
  port: 8080 # 게이트웨이는 MSA 대표 포트인 8080을 사용

spring:
  application:
    name: gateway-service # 서비스 이름 정의

  cloud:
    gateway:
      server:
        webflux:
          httpclient: # 전체 라우트에 적용될 응답 타임 아웃 (단위 : ms)
            response-timeout: 5000 # 5초 안에 응답이 오지 않으면 실패 처리
            connect-timeout: 1000  # 연결 타임아웃 (다운스트림 서비스와 연결을 맺는 시간)
          default-filters: # 모든 라우트에 기본적으로 적용될 필터
            - AuthenticationFilter # 'Filter' 접미사를 제외하고 카멜케이스로 작성
          routes:  # 라우팅 규칙 정의 (routes는 List 형태)
            # --- 회원 서비스 라우트 ---
            - id: member-service-route # 각 라우트의 고유 ID

              # 이 라우트가 최종적으로 요청을 전달할 목적지 URI
              #                      uri: http://localhost:8081 # 로컬
              uri: lb://MEMBER-SERVICE # lb는 로드 벨런서를 의미. "서비스 레지스트리에서 MEMBER-SERVICE라는 이름을 찾아 로드 밸런싱 해줘"

              # 이 라우트가 적용될 조건 (Predicates)
              predicates:
                - Path=/api/v1/members/** # /api/v1/members/로 시작하는 모든 경로
              # 게이트웨이를 통해 member-service를 호출하면 member-service는 요청 헤더에 'X-Request-Source: gateway-service'가 추가된 채로 요청을 받게 됨
              # 클라이언트는 응답 헤더에서 'X-Response-Source: gateway-service' 를 확인할 수 있음
              # name: 필터 이름, args: 필터에 전달할 인자 (key:value)
              filters:
                - name: AddRequestHeader # 내장 필터
                - args:
                    name : X-Request-Source # 헤더의 key
                    value : gateway-service # 헤더의 value

                # 축약형(필터이름=인자1, 인자2,,)
                - AddResponseHeader=X-Response-Source, gateway-service

            # --- 상품 서비스 라우트 ---
            - id: product-service-route # 상품 서비스는 재시도 정책 적용
              #                      uri: http://localhost:8082 # 로컬
              uri : lb://PRODUCT-SERVICE
              predicates:
                - Path=/api/v1/products/**
              # name: 필터 이름, args: 필터에 전달할 인자 (key:value)
              filters:
                - name: Retry # spring cloud gateway 내장 필터
                  args:
                    retries: 3 # 최대 3번까지 재시도
                    statuses: # 어떤 HTTP 상태 코드일 때 재시도 할 것인가?
                      - BAD_GATEWAY # 502
                      - SERVICE_UNAVAILABLE # 503
                      - GATEWAY_TIMEOUT # 504
                    methods: # 어떤 HTTP에만 재시도 할 것인가?
                      - GET # 멱등성(여러 번 호출해도 결과가 같은)이 보장되는 GET, HEAD, OPTIONS 등에만 적용
                    backoff: # 재시도 간격 설정
                      firstBackoff: 100ms # 첫 시도까지 100ms 대기
                      maxBackoff: 500ms # 최대 500ms 까지 늘어남
                      factor: 2 # 대기 시간을 2배씩 증가 (100ms -> 200ms -> 400ms)
                      basedOnPreviousValue: true

            # --- 주문 서비스 라우트 ---
            - id: order-service-route
              uri: http://localhost:8083
              predicates:
                - Path=/api/v1/orders/**

            - id : some-slow-service-route # 예: 외부 시스템과 연동하는 느린 서비스
              uri : http://localhost:8888
              predicates:
                - Path=/api/v1/slow-service/**
              metadata: # 특정 라우트에 대한 타임 아웃 재정의
                response-timeout : 10000 # 이 라우트는 10초까지 기다림
                connect-timeout : 2000


# 실제 프로덕션에서는 환경 변수 등으로 관리
jwt:
  secret: 'a_very_long_and_secure_secret_key_for_ecommerce_project_that_is_at_least_256_bits_long'

# 경로별 권한 생성
# 여기에 명시되지 않은 경로는 인증만 되면 통과
security:
  required-roles: # 'role'키를 가진 경로 목록
    - path: /api/v1/admin/** # '/api/v1/admin/**' 경로는 ADMIN 역할이 필요
      role: ADMIN
    - path: /api/v1/orders/** # '/api/v1/orders/**' 경로는 USER 역할이 필요
      role: USER

eureka:
  client:
    service-url:
      # Eureka 서버(들)의 주소
      defaultZone: http://localhost:8761/eureka/
  instance:
    # IP 주소로 등록되도록 설정
    prefer-ip-address: true

# Actuator의 health 엔드포인트 활성화
management:
  endpoints:
    web:
      exposure:
        include: health,info